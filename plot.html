<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 2D Gaussian Primitive Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a202c;
            color: white;
        }
        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 380px;
            padding: 15px;
            background-color: rgba(45, 55, 72, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        .slider-group {
            margin-bottom: 15px;
        }
        .slider-group h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }
        .slider-container label {
            width: 70px;
            margin-right: 10px;
            text-align: right;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: #4a5568;
            border-radius: 5px;
            outline: none;
        }
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4299e1;
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-container input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4299e1;
            cursor: pointer;
            border-radius: 50%;
        }
        .value-display {
            width: 50px;
            text-align: left;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="ui-panel">
        <div class="slider-group">
            <h3 class="text-blue-300">Primitive 1 (Blue)</h3>
            <!-- Position -->
            <div class="slider-container"><label>Pos X:</label><input type="range" id="p1_pos_x" min="-3" max="3" step="0.01" value="0"><span class="value-display" id="p1_pos_x_val">0.00</span></div>
            <div class="slider-container"><label>Pos Y:</label><input type="range" id="p1_pos_y" min="-3" max="3" step="0.01" value="0.5"><span class="value-display" id="p1_pos_y_val">0.50</span></div>
            <div class="slider-container"><label>Pos Z:</label><input type="range" id="p1_pos_z" min="-3" max="3" step="0.01" value="0"><span class="value-display" id="p1_pos_z_val">0.00</span></div>
            <!-- Rotation -->
            <div class="slider-container"><label>Yaw (Z°):</label><input type="range" id="p1_rot_y" min="-180" max="180" step="1" value="0"><span class="value-display" id="p1_rot_y_val">0</span></div>
            <div class="slider-container"><label>Pitch (Y°):</label><input type="range" id="p1_rot_p" min="-180" max="180" step="1" value="0"><span class="value-display" id="p1_rot_p_val">0</span></div>
            <div class="slider-container"><label>Roll (X°):</label><input type="range" id="p1_rot_r" min="-180" max="180" step="1" value="0"><span class="value-display" id="p1_rot_r_val">0</span></div>
            <!-- Scale -->
            <div class="slider-container"><label>Scale U:</label><input type="range" id="p1_scale_u" min="0.1" max="2" step="0.01" value="0.5"><span class="value-display" id="p1_scale_u_val">0.50</span></div>
            <div class="slider-container"><label>Scale V:</label><input type="range" id="p1_scale_v" min="0.1" max="2" step="0.01" value="0.5"><span class="value-display" id="p1_scale_v_val">0.50</span></div>
        </div>
        <div class="slider-group">
            <h3 class="text-yellow-300">Primitive 2 (Yellow)</h3>
            <!-- Position -->
            <div class="slider-container"><label>Pos X:</label><input type="range" id="p2_pos_x" min="-3" max="3" step="0.01" value="1.5"><span class="value-display" id="p2_pos_x_val">1.50</span></div>
            <div class="slider-container"><label>Pos Y:</label><input type="range" id="p2_pos_y" min="-3" max="3" step="0.01" value="0.5"><span class="value-display" id="p2_pos_y_val">0.50</span></div>
            <div class="slider-container"><label>Pos Z:</label><input type="range" id="p2_pos_z" min="-3" max="3" step="0.01" value="0"><span class="value-display" id="p2_pos_z_val">0.00</span></div>
            <!-- Rotation -->
            <div class="slider-container"><label>Yaw (Z°):</label><input type="range" id="p2_rot_y" min="-180" max="180" step="1" value="45"><span class="value-display" id="p2_rot_y_val">45</span></div>
            <div class="slider-container"><label>Pitch (Y°):</label><input type="range" id="p2_rot_p" min="-180" max="180" step="1" value="30"><span class="value-display" id="p2_rot_p_val">30</span></div>
            <div class="slider-container"><label>Roll (X°):</label><input type="range" id="p2_rot_r" min="-180" max="180" step="1" value="0"><span class="value-display" id="p2_rot_r_val">0</span></div>
            <!-- Scale -->
            <div class="slider-container"><label>Scale U:</label><input type="range" id="p2_scale_u" min="0.1" max="2" step="0.01" value="0.7"><span class="value-display" id="p2_scale_u_val">0.70</span></div>
            <div class="slider-container"><label>Scale V:</label><input type="range" id="p2_scale_v" min="0.1" max="2" step="0.01" value="0.3"><span class="value-display" id="p2_scale_v_val">0.30</span></div>
        </div>
        <p class="text-xs text-gray-400 mt-4">Use mouse to control camera: Left-click + Drag = Rotate, Right-click + Drag = Pan, Scroll = Zoom.</p>
    </div>

    <!-- Import maps for three.js and OrbitControls -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL SETUP ---
        let scene, camera, renderer, controls;
        let primitive1, primitive2;

        // A simple colormap function (viridis) to color points by Gaussian value
        function viridis(value) {
            const colors = [
                [68, 1, 84], [72, 40, 120], [62, 74, 137], [49, 104, 142],
                [38, 130, 142], [31, 158, 137], [53, 183, 121], [109, 205, 89],
                [180, 222, 44], [253, 231, 37]
            ];
            const i = Math.min(Math.max(0, Math.floor(value * (colors.length - 1))), colors.length - 2);
            const t = (value * (colors.length - 1)) % 1;
            const c1 = colors[i];
            const c2 = colors[i + 1];
            return new THREE.Color(
                (c1[0] + t * (c2[0] - c1[0])) / 255,
                (c1[1] + t * (c2[1] - c1[1])) / 255,
                (c1[2] + t * (c2[2] - c1[2])) / 255
            );
        }

        class GaussianPrimitive {
            constructor(initialParams) {
                this.params = initialParams;
                this.nPoints = 50 * 50; // Resolution of the disk
                
                // Pre-calculate the local 2D grid (u,v space)
                const u_coords = np.linspace(-2.5, 2.5, 50);
                const v_coords = np.linspace(-2.5, 2.5, 50);

                // FIX: The original code had a TypeError because JS arrays don't have .ravel()
                // It also had a logical error by trying to perform math operations on entire arrays at once.
                // The corrected code gets the flattened arrays from meshgrid and then loops to calculate values per point.
                const [u, v] = np.meshgrid(u_coords, v_coords);
                this.uv = { u, v };

                // Pre-calculate Gaussian values (colors) as they don't change
                this.gaussianValues = new Float32Array(this.nPoints);
                for (let i = 0; i < this.nPoints; i++) {
                    const distance_sq = this.uv.u[i]**2 + this.uv.v[i]**2;
                    this.gaussianValues[i] = Math.exp(-distance_sq / 2.0);
                }

                // Create Three.js objects
                this.geometry = new THREE.BufferGeometry();
                this.material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
                this.points = new THREE.Points(this.geometry, this.material);
                
                this.update();
            }

            update() {
                // Deconstruct parameters
                const p = new THREE.Vector3(...this.params.position);
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(this.params.rotation[1]), // Pitch (Y)
                    THREE.MathUtils.degToRad(this.params.rotation[0]), // Yaw (Z)
                    THREE.MathUtils.degToRad(this.params.rotation[2]), // Roll (X)
                    'YZX' // Order of rotation
                );
                const s = this.params.scale;

                // Create rotation matrix from Euler angles
                const rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(euler);
                
                // Extract tangential vectors t_u and t_v
                const t_u = new THREE.Vector3().setFromMatrixColumn(rotationMatrix, 0);
                const t_v = new THREE.Vector3().setFromMatrixColumn(rotationMatrix, 1);
                
                const positions = new Float32Array(this.nPoints * 3);
                const colors = new Float32Array(this.nPoints * 3);
                
                for (let i = 0; i < this.nPoints; i++) {
                    // P(u, v) = p + s_u*t_u*u + s_v*t_v*v
                    const u = this.uv.u[i];
                    const v = this.uv.v[i];
                    
                    const pos = new THREE.Vector3()
                        .copy(p)
                        .addScaledVector(t_u, s[0] * u)
                        .addScaledVector(t_v, s[1] * v);
                    
                    pos.toArray(positions, i * 3);
                    
                    // Color based on Gaussian value
                    const color = viridis(this.gaussianValues[i]);
                    color.toArray(colors, i * 3);
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
            }
        }
        
        // Helper for numpy-like linspace and meshgrid
        const np = {
            linspace: (start, stop, num) => Array.from({ length: num }, (_, i) => start + (stop - start) * i / (num - 1)),
            meshgrid: (x, y) => [
                x.map(v => Array(y.length).fill(v)),
                Array(x.length).fill(y)
            ].map(arr => arr.flat())
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(1.5, 2, 4);

            // Renderer
            const container = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            
            // Add Grid Helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x4a5568, 0x3a4558);
            scene.add(gridHelper);

            // Create Primitives
            primitive1 = new GaussianPrimitive({
                position: [0, 0.5, 0],
                rotation: [0, 0, 0], // Yaw, Pitch, Roll
                scale: [0.5, 0.5] // su, sv
            });
            scene.add(primitive1.points);

            primitive2 = new GaussianPrimitive({
                position: [1.5, 0.5, 0],
                rotation: [45, 30, 0],
                scale: [0.7, 0.3]
            });
            scene.add(primitive2.points);
            
            setupUI();
            animate();
        }

        function setupUI() {
            const primitives = [
                { id: 'p1', instance: primitive1 },
                { id: 'p2', instance: primitive2 }
            ];

            primitives.forEach(p => {
                const update = () => {
                    const pos_x = parseFloat(document.getElementById(`${p.id}_pos_x`).value);
                    const pos_y = parseFloat(document.getElementById(`${p.id}_pos_y`).value);
                    const pos_z = parseFloat(document.getElementById(`${p.id}_pos_z`).value);
                    const rot_y = parseFloat(document.getElementById(`${p.id}_rot_y`).value);
                    const rot_p = parseFloat(document.getElementById(`${p.id}_rot_p`).value);
                    const rot_r = parseFloat(document.getElementById(`${p.id}_rot_r`).value);
                    const scale_u = parseFloat(document.getElementById(`${p.id}_scale_u`).value);
                    const scale_v = parseFloat(document.getElementById(`${p.id}_scale_v`).value);

                    p.instance.params.position = [pos_x, pos_y, pos_z];
                    p.instance.params.rotation = [rot_y, rot_p, rot_r];
                    p.instance.params.scale = [scale_u, scale_v];
                    p.instance.update();
                    
                    document.getElementById(`${p.id}_pos_x_val`).textContent = pos_x.toFixed(2);
                    document.getElementById(`${p.id}_pos_y_val`).textContent = pos_y.toFixed(2);
                    document.getElementById(`${p.id}_pos_z_val`).textContent = pos_z.toFixed(2);
                    document.getElementById(`${p.id}_rot_y_val`).textContent = rot_y;
                    document.getElementById(`${p.id}_rot_p_val`).textContent = rot_p;
                    document.getElementById(`${p.id}_rot_r_val`).textContent = rot_r;
                    document.getElementById(`${p.id}_scale_u_val`).textContent = scale_u.toFixed(2);
                    document.getElementById(`${p.id}_scale_v_val`).textContent = scale_v.toFixed(2);
                };

                ['pos_x', 'pos_y', 'pos_z', 'rot_y', 'rot_p', 'rot_r', 'scale_u', 'scale_v'].forEach(param => {
                    document.getElementById(`${p.id}_${param}`).addEventListener('input', update);
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        init();
    </script>
</body>
</html>

