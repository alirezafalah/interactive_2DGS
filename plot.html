<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 2D Gaussian Primitive Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a202c;
            color: white;
        }
        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 380px;
            padding: 15px;
            background-color: rgba(45, 55, 72, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        .slider-group {
            margin-bottom: 15px;
        }
        .slider-group h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }
        .slider-container label {
            width: 70px;
            margin-right: 10px;
            text-align: right;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: #4a5568;
            border-radius: 5px;
            outline: none;
        }
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4299e1;
            cursor: pointer;
            border-radius: 50%;
        }
        .slider-container input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4299e1;
            cursor: pointer;
            border-radius: 50%;
        }
        .value-display {
            width: 50px;
            text-align: left;
            margin-left: 10px;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="ui-panel">
        <div class="slider-group">
            <h3 class="text-blue-300">Primitive 1 (Blue)</h3>
            <!-- Position -->
            <div class="slider-container"><label>Pos X:</label><input type="range" id="p1_pos_x" min="-3" max="3" step="0.01" value="0"><span class="value-display" id="p1_pos_x_val">0.00</span></div>
            <div class="slider-container"><label>Pos Y:</label><input type="range" id="p1_pos_y" min="-3" max="3" step="0.01" value="0.5"><span class="value-display" id="p1_pos_y_val">0.50</span></div>
            <div class="slider-container"><label>Pos Z:</label><input type="range" id="p1_pos_z" min="-3" max="3" step="0.01" value="0"><span class="value-display" id="p1_pos_z_val">0.00</span></div>
            <!-- Rotation -->
            <div class="slider-container"><label>Yaw (Z°):</label><input type="range" id="p1_rot_y" min="-180" max="180" step="1" value="0"><span class="value-display" id="p1_rot_y_val">0</span></div>
            <div class="slider-container"><label>Pitch (Y°):</label><input type="range" id="p1_rot_p" min="-180" max="180" step="1" value="0"><span class="value-display" id="p1_rot_p_val">0</span></div>
            <div class="slider-container"><label>Roll (X°):</label><input type="range" id="p1_rot_r" min="-180" max="180" step="1" value="0"><span class="value-display" id="p1_rot_r_val">0</span></div>
            <!-- Scale -->
            <div class="slider-container"><label>Scale U:</label><input type="range" id="p1_scale_u" min="0.1" max="2" step="0.01" value="0.5"><span class="value-display" id="p1_scale_u_val">0.50</span></div>
            <div class="slider-container"><label>Scale V:</label><input type="range" id="p1_scale_v" min="0.1" max="2" step="0.01" value="0.5"><span class="value-display" id="p1_scale_v_val">0.50</span></div>
        </div>
        <div class="slider-group">
            <h3 class="text-yellow-300">Primitive 2 (Yellow)</h3>
            <!-- Position -->
            <div class="slider-container"><label>Pos X:</label><input type="range" id="p2_pos_x" min="-3" max="3" step="0.01" value="1.5"><span class="value-display" id="p2_pos_x_val">1.50</span></div>
            <div class="slider-container"><label>Pos Y:</label><input type="range" id="p2_pos_y" min="-3" max="3" step="0.01" value="0.5"><span class="value-display" id="p2_pos_y_val">0.50</span></div>
            <div class="slider-container"><label>Pos Z:</label><input type="range" id="p2_pos_z" min="-3" max="3" step="0.01" value="0"><span class="value-display" id="p2_pos_z_val">0.00</span></div>
            <!-- Rotation -->
            <div class="slider-container"><label>Yaw (Z°):</label><input type="range" id="p2_rot_y" min="-180" max="180" step="1" value="45"><span class="value-display" id="p2_rot_y_val">45</span></div>
            <div class="slider-container"><label>Pitch (Y°):</label><input type="range" id="p2_rot_p" min="-180" max="180" step="1" value="30"><span class="value-display" id="p2_rot_p_val">30</span></div>
            <div class="slider-container"><label>Roll (X°):</label><input type="range" id="p2_rot_r" min="-180" max="180" step="1" value="0"><span class="value-display" id="p2_rot_r_val">0</span></div>
            <!-- Scale -->
            <div class="slider-container"><label>Scale U:</label><input type="range" id="p2_scale_u" min="0.1" max="2" step="0.01" value="0.7"><span class="value-display" id="p2_scale_u_val">0.70</span></div>
            <div class="slider-container"><label>Scale V:</label><input type="range" id="p2_scale_v" min="0.1" max="2" step="0.01" value="0.3"><span class="value-display" id="p2_scale_v_val">0.30</span></div>
        </div>
        <div class="slider-group">
            <h3 class="text-gray-300">Visualization Aids</h3>
            <div class="checkbox-container">
                <input type="checkbox" id="show_normals" checked class="mr-2"><label for="show_normals">Show Normal Vectors (t_z)</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="show_samples" checked class="mr-2"><label for="show_samples">Show Regularization Points</label>
            </div>
        </div>
        <p class="text-xs text-gray-400 mt-4">Use mouse to control camera: Left-click + Drag = Rotate, Right-click + Drag = Pan, Scroll = Zoom.</p>
    </div>

    <!-- Import maps for three.js and OrbitControls -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let primitive1, primitive2;

        function viridis(value) {
            const colors = [
                [68, 1, 84], [72, 40, 120], [62, 74, 137], [49, 104, 142],
                [38, 130, 142], [31, 158, 137], [53, 183, 121], [109, 205, 89],
                [180, 222, 44], [253, 231, 37]
            ];
            const i = Math.min(Math.max(0, Math.floor(value * (colors.length - 1))), colors.length - 2);
            const t = (value * (colors.length - 1)) % 1;
            const c1 = colors[i];
            const c2 = colors[i + 1];
            return new THREE.Color(
                (c1[0] + t * (c2[0] - c1[0])) / 255,
                (c1[1] + t * (c2[1] - c1[1])) / 255,
                (c1[2] + t * (c2[2] - c1[2])) / 255
            );
        }

        class GaussianPrimitive {
            constructor(initialParams) {
                this.params = initialParams;
                
                // --- Main Gaussian Disk ---
                this.nGridPoints = 50 * 50;
                const u_coords = np.linspace(-2.5, 2.5, 50);
                const v_coords = np.linspace(-2.5, 2.5, 50);
                const [u, v] = np.meshgrid(u_coords, v_coords);
                this.uv = { u, v };
                
                this.geometry = new THREE.BufferGeometry();
                this.material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
                this.points = new THREE.Points(this.geometry, this.material);
                
                // --- Normal Vector (t_z) ---
                this.normalArrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1, 0xffffff);

                // --- DGPR Sampled Points ---
                this.nSamplePoints = 9;
                const sample_coords = [-1.0, 0.0, 1.0];
                const [su, sv] = np.meshgrid(sample_coords, sample_coords);
                this.sample_uv = { u: su, v: sv };
                this.sampleGeometry = new THREE.BufferGeometry();
                this.sampleMaterial = new THREE.PointsMaterial({ color: 0xff0000, size: 0.08 });
                this.samplePoints = new THREE.Points(this.sampleGeometry, this.sampleMaterial);

                this.update();
            }

            update() {
                const p = new THREE.Vector3(...this.params.position);
                const euler = new THREE.Euler(
                    THREE.MathUtils.degToRad(this.params.rotation[1]), // Pitch (Y)
                    THREE.MathUtils.degToRad(this.params.rotation[0]), // Yaw (Z)
                    THREE.MathUtils.degToRad(this.params.rotation[2]), // Roll (X)
                    'YZX'
                );
                const s = this.params.scale;
                const rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(euler);
                
                const t_u = new THREE.Vector3().setFromMatrixColumn(rotationMatrix, 0);
                const t_v = new THREE.Vector3().setFromMatrixColumn(rotationMatrix, 1);
                const t_z = new THREE.Vector3().setFromMatrixColumn(rotationMatrix, 2); // The normal vector

                // --- FIX: This section now filters points to form a disk ---
                const positions = [];
                const colors = [];
                const radiusSq = 2.5 * 2.5; // We will only draw points within this radius
                
                for (let i = 0; i < this.nGridPoints; i++) {
                    const u = this.uv.u[i];
                    const v = this.uv.v[i];
                    const distance_sq = u**2 + v**2;

                    if (distance_sq < radiusSq) { // Only add points if they are inside the circle
                        const pos = new THREE.Vector3().copy(p).addScaledVector(t_u, s[0] * u).addScaledVector(t_v, s[1] * v);
                        positions.push(pos.x, pos.y, pos.z);
                        
                        const gaussianValue = Math.exp(-distance_sq / 2.0);
                        const color = viridis(gaussianValue);
                        colors.push(color.r, color.g, color.b);
                    }
                }
                
                this.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                // --- END FIX ---
                
                // Update normal vector arrow
                this.normalArrow.position.copy(p);
                this.normalArrow.setDirection(t_z);
                
                // Update DGPR sample points
                const samplePositions = new Float32Array(this.nSamplePoints * 3);
                 for (let i = 0; i < this.nSamplePoints; i++) {
                    const pos = new THREE.Vector3().copy(p).addScaledVector(t_u, s[0] * this.sample_uv.u[i]).addScaledVector(t_v, s[1] * this.sample_uv.v[i]);
                    pos.toArray(samplePositions, i * 3);
                }
                this.sampleGeometry.setAttribute('position', new THREE.BufferAttribute(samplePositions, 3));
                this.sampleGeometry.attributes.position.needsUpdate = true;
            }
        }
        
        const np = {
            linspace: (start, stop, num) => Array.from({ length: num }, (_, i) => start + (stop - start) * i / (num - 1)),
            meshgrid: (x, y) => [ x.map(v => Array(y.length).fill(v)), Array(x.length).fill(y) ].map(arr => arr.flat())
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(1.5, 2, 4);
            const container = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            const gridHelper = new THREE.GridHelper(10, 10, 0x4a5568, 0x3a4558);
            scene.add(gridHelper);

            // Create Primitives and add all their components to the scene
            primitive1 = new GaussianPrimitive({ position: [0, 0.5, 0], rotation: [0, 0, 0], scale: [0.5, 0.5] });
            scene.add(primitive1.points, primitive1.normalArrow, primitive1.samplePoints);

            primitive2 = new GaussianPrimitive({ position: [1.5, 0.5, 0], rotation: [45, 30, 0], scale: [0.7, 0.3] });
            scene.add(primitive2.points, primitive2.normalArrow, primitive2.samplePoints);
            
            setupUI();
            animate();
        }

        function setupUI() {
            const primitives = [ { id: 'p1', instance: primitive1 }, { id: 'p2', instance: primitive2 } ];

            primitives.forEach(p => {
                const update = () => {
                    p.instance.params.position = [parseFloat(document.getElementById(`${p.id}_pos_x`).value), parseFloat(document.getElementById(`${p.id}_pos_y`).value), parseFloat(document.getElementById(`${p.id}_pos_z`).value)];
                    p.instance.params.rotation = [parseFloat(document.getElementById(`${p.id}_rot_y`).value), parseFloat(document.getElementById(`${p.id}_rot_p`).value), parseFloat(document.getElementById(`${p.id}_rot_r`).value)];
                    p.instance.params.scale = [parseFloat(document.getElementById(`${p.id}_scale_u`).value), parseFloat(document.getElementById(`${p.id}_scale_v`).value)];
                    p.instance.update();
                    document.getElementById(`${p.id}_pos_x_val`).textContent = p.instance.params.position[0].toFixed(2);
                    document.getElementById(`${p.id}_pos_y_val`).textContent = p.instance.params.position[1].toFixed(2);
                    document.getElementById(`${p.id}_pos_z_val`).textContent = p.instance.params.position[2].toFixed(2);
                    document.getElementById(`${p.id}_rot_y_val`).textContent = p.instance.params.rotation[0];
                    document.getElementById(`${p.id}_rot_p_val`).textContent = p.instance.params.rotation[1];
                    document.getElementById(`${p.id}_rot_r_val`).textContent = p.instance.params.rotation[2];
                    document.getElementById(`${p.id}_scale_u_val`).textContent = p.instance.params.scale[0].toFixed(2);
                    document.getElementById(`${p.id}_scale_v_val`).textContent = p.instance.params.scale[1].toFixed(2);
                };
                ['pos_x', 'pos_y', 'pos_z', 'rot_y', 'rot_p', 'rot_r', 'scale_u', 'scale_v'].forEach(param => {
                    document.getElementById(`${p.id}_${param}`).addEventListener('input', update);
                });
            });
            
            // Event listeners for the visualization aid checkboxes
            document.getElementById('show_normals').addEventListener('change', (e) => {
                primitive1.normalArrow.visible = e.target.checked;
                primitive2.normalArrow.visible = e.target.checked;
            });
            document.getElementById('show_samples').addEventListener('change', (e) => {
                primitive1.samplePoints.visible = e.target.checked;
                primitive2.samplePoints.visible = e.target.checked;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);
        init();
    </script>
</body>
</html>

